<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Attribute CNN - Optimized</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.11.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 0;
            line-height: 1.5;
            letter-spacing: -0.01em;
        }
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 40px 32px;
        }
        .header {
            margin-bottom: 48px;
            border-bottom: 1px solid #1a1a1a;
            padding-bottom: 32px;
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }
        h1 {
            font-size: 32px;
            font-weight: 600;
            color: #ffffff;
            letter-spacing: -0.03em;
            margin-bottom: 8px;
        }
        .subtitle {
            color: #666666;
            font-size: 14px;
            font-weight: 400;
            letter-spacing: -0.01em;
        }
        .status-badge {
            padding: 6px 14px;
            background: #0f1f0f;
            border: 1px solid #1a331a;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            color: #4ade80;
            letter-spacing: 0.02em;
            text-transform: uppercase;
        }
        .status-badge.inactive {
            background: #1a1a1a;
            border-color: #2a2a2a;
            color: #666666;
        }
        .grid {
            display: grid;
            grid-template-columns: 480px 1fr;
            gap: 32px;
            margin-bottom: 32px;
        }
        @media (max-width: 1200px) {
            .grid { grid-template-columns: 1fr; }
        }
        .panel {
            background: #111111;
            border: 1px solid #1a1a1a;
            border-radius: 12px;
            padding: 32px;
            position: relative;
        }
        .panel-header {
            font-size: 11px;
            font-weight: 600;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header-badge {
            background: #1a1a1a;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 10px;
            color: #999999;
            letter-spacing: 0.05em;
        }
        .field {
            margin-bottom: 24px;
        }
        .field-label {
            display: block;
            margin-bottom: 10px;
            color: #999999;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: -0.01em;
        }
        .field-sublabel {
            display: block;
            color: #4a4a4a;
            font-size: 11px;
            margin-top: 4px;
            font-weight: 400;
        }
        input[type="number"], select {
            width: 100%;
            padding: 12px 14px;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            font-size: 14px;
            background: #0a0a0a;
            color: #e0e0e0;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s;
            font-weight: 500;
        }
        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: #2a2a2a;
            background: #121212;
        }
        input[type="number"]:hover, select:hover {
            border-color: #2a2a2a;
        }
        .file-input-zone {
            width: 100%;
            padding: 32px 20px;
            border: 1.5px dashed #1a1a1a;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #0a0a0a;
            position: relative;
            display: block;
        }
        .file-input-zone:hover {
            border-color: #2a2a2a;
            background: #0f0f0f;
        }
        .file-input-zone.active {
            border-color: #3a3a3a;
            background: #121212;
        }
        .file-input-text {
            font-size: 13px;
            color: #666666;
            font-weight: 500;
            pointer-events: none;
        }
        .file-input-subtext {
            font-size: 11px;
            color: #4a4a4a;
            margin-top: 6px;
            pointer-events: none;
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 24px;
        }
        button {
            background: #ffffff;
            color: #0a0a0a;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Inter', sans-serif;
            letter-spacing: -0.01em;
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.2), transparent);
            opacity: 0;
            transition: opacity 0.15s;
        }
        button:hover:not(:disabled)::before {
            opacity: 1;
        }
        button:hover:not(:disabled) {
            background: #ffffff;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.15);
        }
        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 1px 4px rgba(255, 255, 255, 0.1);
        }
        button:disabled {
            background: #1a1a1a;
            color: #4a4a4a;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button.secondary {
            background: transparent;
            color: #e0e0e0;
            border: 1px solid #2a2a2a;
            box-shadow: none;
        }
        button.secondary::before {
            background: linear-gradient(135deg, rgba(255,255,255,0.05), transparent);
        }
        button.secondary:hover:not(:disabled) {
            background: #1a1a1a;
            border-color: #3a3a3a;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        button.secondary:active:not(:disabled) {
            background: #0f0f0f;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }
        .metric-card {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 16px;
        }
        .metric-label {
            font-size: 10px;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 8px;
            font-weight: 600;
        }
        .metric-value {
            font-size: 24px;
            font-weight: 700;
            color: #ffffff;
            letter-spacing: -0.02em;
        }
        .metric-unit {
            font-size: 14px;
            color: #666666;
            font-weight: 500;
            margin-left: 4px;
        }
        .chart-container {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            height: 280px;
            margin-bottom: 24px;
        }
        .progress-container {
            margin-top: 24px;
        }
        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
        }
        .progress-label {
            font-size: 12px;
            color: #999999;
            font-weight: 500;
        }
        .progress-percent {
            font-size: 12px;
            color: #ffffff;
            font-weight: 600;
            font-feature-settings: 'tnum';
        }
        .progress-bar {
            background: #1a1a1a;
            border-radius: 4px;
            height: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #ffffff;
            transition: width 0.3s;
            border-radius: 4px;
        }
        .result-container {
            margin-top: 32px;
        }
        .result-grid {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 24px;
        }
        .result-image {
            width: 100%;
            border-radius: 8px;
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
        }
        .predictions {
            display: grid;
            gap: 12px;
        }
        .prediction-card {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .prediction-label {
            font-size: 10px;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
            margin-bottom: 6px;
        }
        .prediction-value {
            font-size: 28px;
            font-weight: 700;
            color: #ffffff;
            letter-spacing: -0.02em;
        }
        .prediction-confidence {
            font-size: 11px;
            color: #4a4a4a;
            margin-top: 6px;
            font-weight: 500;
        }
        .confidence-bar {
            width: 80px;
            height: 80px;
            position: relative;
        }
        .confidence-circle {
            fill: none;
            stroke: #1a1a1a;
            stroke-width: 6;
        }
        .confidence-circle-fill {
            fill: none;
            stroke: #ffffff;
            stroke-width: 6;
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: center;
            transition: stroke-dashoffset 0.5s;
        }
        .confidence-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 16px;
            font-weight: 700;
            color: #ffffff;
        }
        .alert {
            padding: 14px 18px;
            background: #0f1f0f;
            border: 1px solid #1a331a;
            border-radius: 8px;
            margin-bottom: 24px;
            font-size: 12px;
            color: #4ade80;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .alert-warning {
            background: #1f1f0f;
            border-color: #33331a;
            color: #fbbf24;
        }
        .alert-info {
            background: #0f1a1f;
            border-color: #1a2633;
            color: #60a5fa;
        }
        .alert-icon {
            font-size: 14px;
        }
        .info-footer {
            background: #0a0a0a;
            border: 1px solid #1a1a1a;
            border-radius: 12px;
            padding: 24px 28px;
            font-size: 12px;
            color: #666666;
            line-height: 1.8;
            position: relative;
        }
        .info-footer strong {
            color: #999999;
            font-weight: 600;
        }
        .memory-monitor {
            position: fixed;
            top: 24px;
            right: 24px;
            background: #111111;
            border: 1px solid #1a1a1a;
            border-radius: 8px;
            padding: 16px;
            font-size: 11px;
            color: #666666;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
        .memory-monitor-title {
            font-weight: 600;
            color: #999999;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-size: 10px;
        }
        .memory-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }
        .memory-stat-value {
            font-weight: 600;
            color: #ffffff;
        }
        .memory-stat-value.warning {
            color: #fbbf24;
        }
        .memory-stat-value.danger {
            color: #ef4444;
        }
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <div class="memory-monitor" id="memoryMonitor">
        <div class="memory-monitor-title">GPU Memory</div>
        <div class="memory-stat">
            <span>Usage:</span>
            <span class="memory-stat-value" id="memUsage">0 MB</span>
        </div>
        <div class="memory-stat">
            <span>Tensors:</span>
            <span class="memory-stat-value" id="tensorCount">0</span>
        </div>
        <div class="memory-stat">
            <span>Status:</span>
            <span class="memory-stat-value" id="memStatus">OK</span>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <div class="header-content">
                <div>
                    <h1>Face Attribute CNN - Optimized</h1>
                    <p class="subtitle">Memory-efficient regression neural network</p>
                </div>
                <div class="status-badge inactive" id="modelStatus">Model Inactive</div>
            </div>
        </div>

        <div class="grid">
            <div class="panel">
                <div class="panel-header">
                    Training Configuration
                    <span class="panel-header-badge">UTK Dataset</span>
                </div>
                
                <div class="alert alert-info">
                    <span class="alert-icon">ℹ</span>
                    <span>Memory optimized: Start with 2000 images, 64px resolution</span>
                </div>
                
                <div class="alert alert-warning">
                    <span class="alert-icon">⚠</span>
                    <span>Prevent your computer from sleeping during training!</span>
                </div>
                
                <div class="field">
                    <label class="field-label">
                        Image Resolution
                        <span class="field-sublabel">Start small to avoid memory issues</span>
                    </label>
                    <select id="imgSize">
                        <option value="64" selected>64 × 64 px (Recommended)</option>
                        <option value="96">96 × 96 px</option>
                        <option value="128">128 × 128 px</option>
                    </select>
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">Max Images</div>
                        <input type="number" id="maxImg" value="2000" min="500" max="5000" style="background:transparent;border:none;padding:0;font-size:24px;font-weight:700;color:#fff;height:auto;">
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Epochs</div>
                        <input type="number" id="epochs" value="30" min="10" max="100" style="background:transparent;border:none;padding:0;font-size:24px;font-weight:700;color:#fff;height:auto;">
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Batch Size</div>
                        <div class="metric-value">32</div>
                    </div>
                </div>
                
                <div class="field">
                    <label class="field-label">Training Dataset</label>
                    <label for="trainFiles" class="file-input-zone">
                        <div class="file-input-text" id="trainFileText">Select Folder</div>
                        <div class="file-input-subtext">Format: age_gender_race_date.jpg</div>
                    </label>
                    <input type="file" id="trainFiles" webkitdirectory directory multiple>
                </div>
                
                <div class="btn-group">
                    <button onclick="train()" id="trainBtn">Start Training</button>
                    <button onclick="saveModel()" id="saveBtn" disabled class="secondary">Save</button>
                    <button onclick="document.getElementById('loadModelJson').click()" class="secondary">Load</button>
                </div>
                <input type="file" id="loadModelJson" accept=".json" style="display:none;">
                <input type="file" id="loadModelWeights" accept=".bin" style="display:none;">
                
                <div id="progress"></div>
            </div>

            <div class="panel">
                <div class="panel-header">
                    Training Metrics
                    <span class="panel-header-badge">Real-time</span>
                </div>
                
                <div class="chart-container">
                    <canvas id="lossChart"></canvas>
                </div>
                
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">Current Epoch</div>
                        <div class="metric-value" id="currentEpoch">0<span class="metric-unit">/ 0</span></div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Age MAE</div>
                        <div class="metric-value" id="ageMae">—</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total Loss</div>
                        <div class="metric-value" id="trainLoss">—</div>
                    </div>
                </div>

                <div class="panel-header" style="margin-top:32px">
                    Prediction
                </div>
                
                <div class="field">
                    <label for="testFile" class="file-input-zone">
                        <div class="file-input-text" id="testFileText">Upload Image</div>
                        <div class="file-input-subtext">Analyze facial attributes</div>
                    </label>
                    <input type="file" id="testFile" accept="image/*">
                </div>
                
                <button onclick="predict()" id="predBtn" disabled style="width:100%;margin-top:16px">Analyze Face</button>
                
                <div id="results"></div>
            </div>
        </div>

        <div class="info-footer">
            <strong>Memory Optimizations:</strong> Batch processing, aggressive tensor cleanup, reduced model size, smaller default resolution. <strong>Quick Start:</strong> Download UTK Face dataset → Use 64×64 resolution → Select 2000 images → Train 30 epochs → Save model → Upload images for predictions.
        </div>
    </div>

    <script>
        let model = null;
        let imgSize = 64;
        let chart = null;
        let memoryInterval = null;

        tf.setBackend('webgl').then(() => tf.ready());

        // Memory monitoring
        function startMemoryMonitoring() {
            if (memoryInterval) clearInterval(memoryInterval);
            memoryInterval = setInterval(() => {
                const mem = tf.memory();
                const mb = (mem.numBytes / 1024 / 1024).toFixed(1);
                const tensors = mem.numTensors;
                
                document.getElementById('memUsage').textContent = `${mb} MB`;
                document.getElementById('tensorCount').textContent = tensors;
                
                const usageElem = document.getElementById('memUsage');
                const statusElem = document.getElementById('memStatus');
                
                if (mem.numBytes > 800 * 1024 * 1024) {
                    usageElem.className = 'memory-stat-value danger';
                    statusElem.className = 'memory-stat-value danger';
                    statusElem.textContent = 'CRITICAL';
                } else if (mem.numBytes > 500 * 1024 * 1024) {
                    usageElem.className = 'memory-stat-value warning';
                    statusElem.className = 'memory-stat-value warning';
                    statusElem.textContent = 'HIGH';
                } else {
                    usageElem.className = 'memory-stat-value';
                    statusElem.className = 'memory-stat-value';
                    statusElem.textContent = 'OK';
                }
            }, 2000);
        }

        startMemoryMonitoring();

        // Initialize chart
        const ctx = document.getElementById('lossChart').getContext('2d');
        Chart.defaults.color = '#666666';
        Chart.defaults.borderColor = '#1a1a1a';
        chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Training Loss',
                        data: [],
                        borderColor: '#ffffff',
                        backgroundColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        pointBackgroundColor: '#ffffff',
                        fill: false
                    },
                    {
                        label: 'Validation Loss',
                        data: [],
                        borderColor: '#666666',
                        backgroundColor: 'rgba(102, 102, 102, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        pointBackgroundColor: '#666666',
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            color: '#666666',
                            font: { family: 'Inter', size: 11, weight: '500' },
                            padding: 16,
                            usePointStyle: true,
                            pointStyle: 'circle'
                        }
                    },
                    tooltip: {
                        backgroundColor: '#1a1a1a',
                        titleColor: '#ffffff',
                        bodyColor: '#999999',
                        borderColor: '#2a2a2a',
                        borderWidth: 1,
                        padding: 12,
                        displayColors: true,
                        titleFont: { family: 'Inter', size: 12, weight: '600' },
                        bodyFont: { family: 'Inter', size: 11 }
                    }
                },
                scales: {
                    x: {
                        grid: { color: '#1a1a1a', drawBorder: false },
                        ticks: { color: '#666666', font: { family: 'Inter', size: 10 } },
                        title: {
                            display: true,
                            text: 'Epoch',
                            color: '#666666',
                            font: { family: 'Inter', size: 10, weight: '500' }
                        }
                    },
                    y: {
                        grid: { color: '#1a1a1a', drawBorder: false },
                        ticks: { color: '#666666', font: { family: 'Inter', size: 10 } },
                        title: {
                            display: true,
                            text: 'Loss',
                            color: '#666666',
                            font: { family: 'Inter', size: 10, weight: '500' }
                        }
                    }
                }
            }
        });

        // File input handlers
        document.getElementById('trainFiles').addEventListener('change', (e) => {
            const count = e.target.files.length;
            document.getElementById('trainFileText').textContent = `${count} files selected`;
            document.getElementById('trainFileText').parentElement.classList.add('active');
        });

        document.getElementById('testFile').addEventListener('change', (e) => {
            const name = e.target.files[0]?.name || 'Upload Image';
            document.getElementById('testFileText').textContent = name.length > 30 ? name.substring(0, 27) + '...' : name;
            document.getElementById('testFileText').parentElement.classList.add('active');
        });

        function buildModel(size) {
            const m = tf.sequential();
            
            // Optimized architecture - fewer layers to reduce memory
            m.add(tf.layers.conv2d({ inputShape: [size, size, 3], filters: 32, kernelSize: 3, activation: 'relu', padding: 'same' }));
            m.add(tf.layers.batchNormalization());
            m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
            m.add(tf.layers.dropout({ rate: 0.25 }));
            
            m.add(tf.layers.conv2d({ filters: 64, kernelSize: 3, activation: 'relu', padding: 'same' }));
            m.add(tf.layers.batchNormalization());
            m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
            m.add(tf.layers.dropout({ rate: 0.25 }));
            
            m.add(tf.layers.conv2d({ filters: 128, kernelSize: 3, activation: 'relu', padding: 'same' }));
            m.add(tf.layers.batchNormalization());
            m.add(tf.layers.maxPooling2d({ poolSize: 2 }));
            m.add(tf.layers.dropout({ rate: 0.3 }));
            
            m.add(tf.layers.flatten());
            
            m.add(tf.layers.dense({ units: 256, activation: 'relu', kernelRegularizer: tf.regularizers.l2({ l2: 0.001 }) }));
            m.add(tf.layers.batchNormalization());
            m.add(tf.layers.dropout({ rate: 0.4 }));
            
            m.add(tf.layers.dense({ units: 128, activation: 'relu', kernelRegularizer: tf.regularizers.l2({ l2: 0.001 }) }));
            m.add(tf.layers.dropout({ rate: 0.3 }));
            
            // Output layer: 8 neurons for regression
            m.add(tf.layers.dense({ units: 8 }));
            
            m.compile({
                optimizer: tf.train.adam(0.0003),
                loss: (yTrue, yPred) => tf.tidy(() => {
                    // Clip predictions to prevent explosions
                    const predClipped = tf.clipByValue(yPred, -10, 10);
                    
                    const ageLoss = tf.losses.meanSquaredError(
                        yTrue.slice([0,0],[-1,1]), 
                        predClipped.slice([0,0],[-1,1])
                    );
                    
                    const genderLoss = tf.losses.softmaxCrossEntropy(
                        yTrue.slice([0,1],[-1,2]), 
                        predClipped.slice([0,1],[-1,2])
                    );
                    
                    const raceLoss = tf.losses.softmaxCrossEntropy(
                        yTrue.slice([0,3],[-1,5]), 
                        predClipped.slice([0,3],[-1,5])
                    );
                    
                    // Simpler weighting to prevent instability
                    return ageLoss.mul(10).add(genderLoss).add(raceLoss).div(12);
                }),
                metrics: ['mae']
            });
            return m;
        }

        function parseLabels(name) {
            const p = name.split('_');
            if (p.length < 3) return null;
            const age = parseInt(p[0]), gender = parseInt(p[1]), race = parseInt(p[2]);
            if (isNaN(age) || isNaN(gender) || isNaN(race) || age < 0 || age > 116) return null;
            return { age, gender, race };
        }

        async function loadImg(file, size, augment = false) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    
                    if (augment) {
                        if (Math.random() > 0.5) {
                            ctx.translate(size, 0);
                            ctx.scale(-1, 1);
                        }
                        const brightness = 0.85 + Math.random() * 0.3;
                        const contrast = 0.85 + Math.random() * 0.3;
                        ctx.filter = `brightness(${brightness}) contrast(${contrast})`;
                    }
                    
                    ctx.drawImage(img, 0, 0, size, size);
                    
                    const tensor = tf.tidy(() => {
                        return tf.browser.fromPixels(canvas).toFloat().div(255.0);
                    });
                    
                    URL.revokeObjectURL(img.src);
                    resolve(tensor);
                };
                img.src = URL.createObjectURL(file);
            });
        }

        function encode(l) {
            const ageNorm = Math.log(l.age + 1) / Math.log(117);
            const gender = l.gender === 0 ? [1,0] : [0,1];
            const race = [0,0,0,0,0];
            if (l.race >= 0 && l.race < 5) race[l.race] = 1;
            return [ageNorm, ...gender, ...race];
        }

        async function train() {
            const files = document.getElementById('trainFiles').files;
            const maxImg = parseInt(document.getElementById('maxImg').value);
            const size = parseInt(document.getElementById('imgSize').value);
            const epochs = parseInt(document.getElementById('epochs').value);
            imgSize = size;
            
            if (!files.length) return alert('Select training folder');

            const btn = document.getElementById('trainBtn');
            const progress = document.getElementById('progress');
            btn.disabled = true;
            btn.textContent = 'Training...';
            
            // Request wake lock to prevent sleep during training
            let wakeLock = null;
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock active - screen will stay awake');
                }
            } catch (err) {
                console.warn('Wake Lock not supported:', err);
            }
            
            chart.data.labels = [];
            chart.data.datasets[0].data = [];
            chart.data.datasets[1].data = [];
            chart.update();
            
            const showProgress = (text, pct) => {
                progress.innerHTML = `<div class="progress-container">
                    <div class="progress-header">
                        <div class="progress-label">${text}</div>
                        <div class="progress-percent">${pct.toFixed(0)}%</div>
                    </div>
                    <div class="progress-bar"><div class="progress-fill" style="width:${pct}%"></div></div>
                </div>`;
            };
            
            showProgress('Initializing model...', 0);
            
            if (model) model.dispose();
            model = buildModel(size);
            
            const valid = Array.from(files).filter(f => f.type.startsWith('image/') && parseLabels(f.name));
            
            // Better shuffle using Fisher-Yates algorithm
            const shuffleArray = (array) => {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            };
            
            const shuffled = shuffleArray(valid).slice(0, maxImg);
            
            if (!shuffled.length) {
                alert('No valid images');
                btn.disabled = false;
                btn.textContent = 'Start Training';
                return;
            }

            // BATCH PROCESSING - Process images in chunks to avoid memory overload
            const LOAD_BATCH_SIZE = 300;
            const batches = [];
            for (let i = 0; i < shuffled.length; i += LOAD_BATCH_SIZE) {
                batches.push(shuffled.slice(i, i + LOAD_BATCH_SIZE));
            }

            const allXs = [];
            const allYs = [];
            
            for (let batchIdx = 0; batchIdx < batches.length; batchIdx++) {
                const batch = batches[batchIdx];
                const xs = [], ys = [];
                
                for (let i = 0; i < batch.length; i++) {
                    const f = batch[i];
                    const tensor = await loadImg(f, size, true);
                    const labels = parseLabels(f.name);
                    xs.push(tensor);
                    ys.push(encode(labels));
                    
                    const totalProcessed = batchIdx * LOAD_BATCH_SIZE + i + 1;
                    if (totalProcessed % 50 === 0) {
                        showProgress(`Loading images: ${totalProcessed} / ${shuffled.length}`, (totalProcessed/shuffled.length)*100);
                        await tf.nextFrame();
                    }
                }
                
                // Stack this batch
                const xBatch = tf.stack(xs);
                const yBatch = tf.tensor2d(ys);
                
                allXs.push(xBatch);
                allYs.push(yBatch);
                
                // Cleanup individual tensors
                xs.forEach(t => t.dispose());
                
                await tf.nextFrame();
                
                showProgress(`Processing batch ${batchIdx + 1} / ${batches.length}`, ((batchIdx + 1)/batches.length)*100);
            }

            showProgress('Concatenating data...', 100);
            await tf.nextFrame();
            
            // Combine all batches
            const xTrain = tf.concat(allXs);
            const yTrain = tf.concat(allYs);
            
            // Cleanup batch tensors
            allXs.forEach(t => t.dispose());
            allYs.forEach(t => t.dispose());

            document.getElementById('currentEpoch').innerHTML = `0<span class="metric-unit">/ ${epochs}</span>`;

            await model.fit(xTrain, yTrain, {
                epochs,
                batchSize: 32,
                validationSplit: 0.15,
                shuffle: true,
                callbacks: {
                    onEpochEnd: async (epoch, logs) => {
                        const pct = ((epoch+1)/epochs)*100;
                        
                        const sampleSize = Math.min(100, xTrain.shape[0]);
                        let ageMae = 0;
                        
                        try {
                            ageMae = tf.tidy(() => {
                                const pred = model.predict(xTrain.slice([0,0,0,0], [sampleSize,size,size,3]));
                                const predSlice = pred.slice([0,0], [sampleSize, 1]);
                                const trueSlice = yTrain.slice([0,0], [sampleSize,1]);
                                
                                // Clip predictions before calculating MAE
                                const predClipped = tf.clipByValue(predSlice, 0, 1);
                                const predAges = predClipped.mul(Math.log(117)).exp().sub(1);
                                const trueAges = trueSlice.mul(Math.log(117)).exp().sub(1);
                                const mae = predAges.sub(trueAges).abs().mean();
                                
                                const maeVal = mae.dataSync()[0];
                                
                                // Check for NaN
                                if (isNaN(maeVal) || !isFinite(maeVal)) {
                                    return 999.9; // Indicate error
                                }
                                
                                return maeVal;
                            });
                        } catch (e) {
                            ageMae = 999.9;
                            console.error('MAE calculation error:', e);
                        }
                        
                        showProgress(`Epoch ${epoch+1} / ${epochs}`, pct);
                        
                        document.getElementById('currentEpoch').innerHTML = `${epoch+1}<span class="metric-unit">/ ${epochs}</span>`;
                        document.getElementById('ageMae').textContent = ageMae.toFixed(1) + ' yrs';
                        document.getElementById('trainLoss').textContent = logs.loss.toFixed(4);
                        
                        chart.data.labels.push(epoch + 1);
                        chart.data.datasets[0].data.push(logs.loss);
                        chart.data.datasets[1].data.push(logs.val_loss);
                        chart.update('none');
                        
                        await tf.nextFrame();
                    },
                    onBatchEnd: async (batch) => {
                        if (batch % 5 === 0) await tf.nextFrame();
                    }
                }
            });

            xTrain.dispose();
            yTrain.dispose();
            
            // Release wake lock
            if (wakeLock) {
                await wakeLock.release();
                console.log('Wake Lock released');
            }
            
            btn.textContent = 'Start Training';
            btn.disabled = false;
            document.getElementById('predBtn').disabled = false;
            document.getElementById('saveBtn').disabled = false;
            document.getElementById('modelStatus').textContent = 'Model Active';
            document.getElementById('modelStatus').classList.remove('inactive');
            progress.innerHTML = '<div class="alert"><span class="alert-icon">✓</span><span>Training complete</span></div>';
        }

        async function saveModel() {
            if (!model) return alert('No model to save');
            
            const progress = document.getElementById('progress');
            progress.innerHTML = '<div class="alert alert-info"><span class="alert-icon">↻</span><span>Saving model...</span></div>';
            
            try {
                await model.save('downloads://face-cnn-optimized');
                progress.innerHTML = '<div class="alert"><span class="alert-icon">✓</span><span>Model saved! Two files downloaded: model.json and model.weights.bin</span></div>';
            } catch (e) {
                progress.innerHTML = `<div class="alert alert-warning"><span class="alert-icon">✕</span><span>Save error: ${e.message}</span></div>`;
            }
        }

        // Setup load model handlers
        document.getElementById('loadModelJson').addEventListener('change', async (e) => {
            const jsonFile = e.target.files[0];
            if (!jsonFile) return;
            
            const progress = document.getElementById('progress');
            progress.innerHTML = '<div class="alert alert-info"><span class="alert-icon">↻</span><span>Select the weights file (.bin)...</span></div>';
            
            // Trigger weights file selection
            const weightsInput = document.getElementById('loadModelWeights');
            weightsInput.onchange = async (evt) => {
                const weightsFile = evt.target.files[0];
                if (!weightsFile) {
                    progress.innerHTML = '<div class="alert alert-warning"><span class="alert-icon">✕</span><span>Weights file required</span></div>';
                    return;
                }
                
                await loadModel(jsonFile, weightsFile);
                
                // Reset inputs
                e.target.value = '';
                evt.target.value = '';
            };
            
            weightsInput.click();
        });

        async function loadModel(jsonFile, weightsFile) {
            const progress = document.getElementById('progress');
            progress.innerHTML = '<div class="alert alert-info"><span class="alert-icon">↻</span><span>Loading model...</span></div>';
            
            try {
                const json = JSON.parse(await jsonFile.text());
                imgSize = json.modelTopology.config.layers[0].config.batch_input_shape[1];
                
                if (model) model.dispose();
                model = await tf.loadLayersModel(tf.io.browserFiles([jsonFile, weightsFile]));
                
                document.getElementById('imgSize').value = imgSize;
                document.getElementById('predBtn').disabled = false;
                document.getElementById('saveBtn').disabled = false;
                document.getElementById('modelStatus').textContent = 'Model Active';
                document.getElementById('modelStatus').classList.remove('inactive');
                progress.innerHTML = `<div class="alert"><span class="alert-icon">✓</span><span>Model loaded successfully (${imgSize}×${imgSize})</span></div>`;
            } catch (e) {
                progress.innerHTML = `<div class="alert alert-warning"><span class="alert-icon">✕</span><span>Load error: ${e.message}</span></div>`;
                console.error('Model load error:', e);
            }
        }

        async function predict() {
            if (!model) return alert('Train or load a model first');

            const file = document.getElementById('testFile').files[0];
            if (!file) return alert('Select an image');

            const tensor = await loadImg(file, imgSize, false);
            const pred = model.predict(tensor.expandDims(0));
            const vals = await pred.data();
            
            // Clip and validate predictions
            const ageVal = Math.max(0, Math.min(1, vals[0]));
            const age = Math.round(Math.exp(ageVal * Math.log(117)) - 1);
            
            // Check for NaN
            if (isNaN(age) || !isFinite(age)) {
                alert('Model prediction error. Please retrain the model.');
                tensor.dispose();
                pred.dispose();
                return;
            }
            
            const softmax = arr => {
                const exp = arr.map(x => Math.exp(x));
                const sum = exp.reduce((a,b) => a+b);
                return exp.map(x => x/sum);
            };
            
            const genderProbs = softmax([vals[1], vals[2]]);
            const gender = genderProbs[0] > genderProbs[1] ? 'Male' : 'Female';
            const genderConf = Math.max(...genderProbs) * 100;
            
            const raceProbs = softmax([vals[3], vals[4], vals[5], vals[6], vals[7]]);
            const raceIdx = raceProbs.indexOf(Math.max(...raceProbs));
            const races = ['White', 'Black', 'Asian', 'Indian', 'Others'];
            const race = races[raceIdx];
            const raceConf = raceProbs[raceIdx] * 100;
            
            const reader = new FileReader();
            reader.onload = e => {
                const circumference = 2 * Math.PI * 34;
                const createConfCircle = (conf) => {
                    const offset = circumference - (conf / 100) * circumference;
                    return `<svg class="confidence-bar" viewBox="0 0 80 80">
                        <circle class="confidence-circle" cx="40" cy="40" r="34"/>
                        <circle class="confidence-circle-fill" cx="40" cy="40" r="34" 
                            stroke-dasharray="${circumference}" stroke-dashoffset="${offset}"/>
                    </svg>
                    <div class="confidence-text">${conf.toFixed(0)}%</div>`;
                };
                
                document.getElementById('results').innerHTML = `
                    <div class="result-container">
                        <div class="result-grid">
                            <img src="${e.target.result}" class="result-image" alt="Input">
                            <div class="predictions">
                                <div class="prediction-card">
                                    <div>
                                        <div class="prediction-label">Age (Regression)</div>
                                        <div class="prediction-value">${age}</div>
                                        <div class="prediction-confidence">years old</div>
                                    </div>
                                </div>
                                <div class="prediction-card">
                                    <div>
                                        <div class="prediction-label">Gender</div>
                                        <div class="prediction-value">${gender}</div>
                                        <div class="prediction-confidence">Confidence: ${genderConf.toFixed(1)}%</div>
                                    </div>
                                    <div style="position:relative">
                                        ${createConfCircle(genderConf)}
                                    </div>
                                </div>
                                <div class="prediction-card">
                                    <div>
                                        <div class="prediction-label">Ethnicity</div>
                                        <div class="prediction-value">${race}</div>
                                        <div class="prediction-confidence">Confidence: ${raceConf.toFixed(1)}%</div>
                                    </div>
                                    <div style="position:relative">
                                        ${createConfCircle(raceConf)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            };
            reader.readAsDataURL(file);
            
            tensor.dispose();
            pred.dispose();
        }
    </script>
</body>
</html>